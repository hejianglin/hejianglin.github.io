---
title: 程序编译过程
date: 2018-05-12 08:55:06
categories:  compiler
description : 程序编译过程介绍
tags : compiler 
---

我们都知道build的4个过程

- 预处理(prepressing)
- 编译(compilation)
- 汇编(assembly)
- 链接(linking)

我们以最简单'hello,world'来进行讲述这几个过程

<!--more-->

## 预处理

通过编译器生成预编译完成的.i文件

```
$ gcc -E hello.c hello.i 
```

预处理最大的作用自然就是处理预编译指令,因此可以通过这样的方式看下我们的宏定义是否正确,其中:

```
# 55 "/usr/include/sys/_types.h" 3 4
```

用于编译器产生调试用的行号信息及产生编译错误或警告时显示行号,关于这一个，有待后续研究

## 编译

**编译的最终结果是为了将源代码生成汇编代码** 可以通过'-S'来生成,比如:

```
gcc -S hello.i -o hello.s
```

## 汇编

**汇编的最终结果是为了将汇编代码生成机器代码**可以通过as或者'-C'得到目标文件,比如:

```
as hello.s -o hello.o
```

或者

```
gcc -c hello.c -o hello.o
```

查看.o文件可以使用命令xxd

## 链接

### 为什么需要链接

讲述链接之前我们再研究一下为什么我们需要链接，下面是编译在编译源程序的具体工作流程: ![编译器处理编译的详细过程](https://pic.superbed.cn/item/5db93135bd461d945a58a928.png)

#### 1. 词法分析:

通过类似有限状态机(你可以认为是if..else...)将代码中的字符分解成它所能理解的最小片(tokens)

**代表工具:lex**

#### 2. 语法分析:

将代码解析成语法树(syntax tree)

> 分析时各逻辑/算术符号将按优先级进行解析

**代表工具:yacc**

#### 3. 语义分析

代码中存在的语义存在两种类型

- 静态语义(static semantic):包括声明和类型的匹配
- 动态语义(dynamic semantic):运行期间的错误

编译器只能进行静态语义的分析

#### 4. 中间语言生成

编译器优化(前端) + 生成目标机器代码(后端)
区分前后端的原因在于:不同平台的机器代码不同,但优化的前端代码是一致的

> 注:中间语言的生成只是包含编译器优化的代码,生成机器代码是步骤5

#### 5. 目标代码的生成和优化

#### 6. 总结

经历了这些步骤之后，我们编生成了源代码的目标码？然而回想一下你的源码，如果是单文件源码，那我们自然知道变量的地址，如果非单文件我们又是如何确定变量的地址的?
此时就需要链接了!!!

### 链接做了什么什么

**链接的最终目的是填各变量/函数的地址**
下图所示就是链接在编译过程所在的位置:

![链接](https://pic.superbed.cn/item/5db93167bd461d945a58ac53.png)

其中Library其实就是Runtime Library,也可以认为是一组目标文件的包
